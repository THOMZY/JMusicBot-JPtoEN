/* Copyright 2025 THOMZY */

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMusicBot Web Panel</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Add this CSS to the existing styles */
        .progress-container {
            position: relative;
            cursor: pointer;
            height: 8px;
            background-color: #3c3f45;
            border-radius: 4px;
            transition: height 0.2s;
            margin-bottom: 10px; /* Add space for the preview */
        }
        
        .progress-container:hover {
            height: 12px;
        }
        
        .progress-container:hover .progress-bar {
            background: linear-gradient(90deg, #5865f2, #7289da);
        }
        
        .progress-bar {
            height: 100%;
            background-color: #5865f2;
            border-radius: 4px;
            transition: width 0.1s;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            width: 12px;
            height: 12px;
            background-color: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .progress-container:hover .progress-handle {
            opacity: 1;
        }
        
        .progress-preview {
            position: absolute;
            bottom: 25px;
            background-color: #2c2f33;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 14px;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid #3c3f45;
            font-weight: bold;
            z-index: 10;
            white-space: nowrap;
        }
        
        .progress-preview::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #2c2f33 transparent transparent transparent;
        }
        
        .progress-container .progress-preview {
            opacity: 0;
        }
        
        .progress-container:hover .progress-preview {
            opacity: 1;
        }
        
        /* Seek-time tooltip */
        .time-tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: nowrap;
            text-align: center;
        }
        
        /* Add a slight highlighting effect when clicking */
        .progress-container:active {
            background-color: #4a4d55;
        }
        
        .progress-container:active .progress-handle {
            transform: translate(-50%, -50%) scale(1.2);
            background-color: #ffffff;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="main-header">
        <div class="header-container">
            <div class="logo-area">
                <div class="logo">JMusicBot</div>
                <div class="server-dropdown">
                    <button class="server-select-btn" id="server-dropdown-btn">
                        <img class="server-icon" id="selected-server-icon" src="https://cdn.discordapp.com/embed/avatars/0.png" alt="Server Icon">
                        <span class="server-name" id="selected-server-name">Loading servers...</span>
                        <i class="fas fa-chevron-down dropdown-arrow"></i>
                    </button>
                    <div class="server-dropdown-content" id="server-dropdown-content">
                        <!-- Server items will be added here dynamically -->
                    </div>
                </div>
            </div>
            <div class="nav-buttons">
                <button class="bot-profile-btn" id="bot-profile-btn">
                    <div class="bot-avatar-container">
                        <img class="bot-avatar" id="bot-avatar" src="https://cdn.discordapp.com/embed/avatars/0.png" alt="Bot Avatar">
                        <div class="status-indicator" id="bot-status-indicator"></div>
                    </div>
                    <span class="bot-name" id="bot-name">Loading...</span>
                </button>
                <button class="nav-btn" id="console-btn">
                    <i class="fas fa-terminal"></i> Console
                </button>
                <button class="nav-btn" id="config-btn">
                    <i class="fas fa-cog"></i> Config
                </button>
                <button class="nav-btn" id="reboot-btn">
                    <i class="fas fa-sync"></i> Reboot
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Player Section -->
        <div class="player-container">
            <div class="player-content">
                <div class="album-art">
                    <img id="track-thumbnail" src="https://cdn.discordapp.com/embed/avatars/0.png" alt="Album Art">
                </div>
                <div class="track-info">
                    <div class="track-title" id="track-title">No track playing</div>
                    <div class="track-author" id="track-author"></div>
                    <div class="track-metadata">
                        <div class="metadata-item" id="track-source">
                            <i class="fas fa-link"></i> <span id="track-source-text">Source: Unknown</span>
                        </div>
                        <div class="metadata-item">
                            <i class="fas fa-volume-up"></i> <span id="track-volume">Volume: 100%</span>
                        </div>
                        <div class="metadata-item">
                            <i class="fas fa-user"></i> <span id="track-requester">Requested by: Unknown</span>
                        </div>
                    </div>
                    <div class="status" id="status-message">
                        Connecting to server...
                    </div>
                </div>
            </div>
            <div class="progress-container" id="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
                <div class="progress-handle" id="progress-handle"></div>
                <div class="progress-preview" id="progress-preview">0:00 / 0:00</div>
            </div>
            <div class="time-display">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
            <div class="controls">
                <button id="play-button" disabled><i class="fas fa-play"></i> Play</button>
                <button id="pause-button" disabled><i class="fas fa-pause"></i> Pause</button>
                <button id="skip-button" disabled><i class="fas fa-forward"></i> Skip</button>
                <button id="stop-button" disabled><i class="fas fa-stop"></i> Stop</button>
            </div>
        </div>

        <!-- Queue Section -->
        <div class="queue-container">
            <div class="queue-header">
                <div class="queue-title">Current Queue</div>
                <div class="queue-info" id="queue-info">Queue: 0 tracks</div>
            </div>
            <div class="queue-list" id="queue-list">
                <!-- Queue items will be added here dynamically -->
            </div>
        </div>

        <!-- Add Track Section -->
        <div class="add-track-container">
            <form id="add-url-form" class="add-track-form">
                <input type="text" id="url-input" class="add-track-input" placeholder="Enter a URL to add music (YouTube, SoundCloud, etc)...">
                <button type="submit"><i class="fas fa-plus"></i> Add to Queue</button>
            </form>
            <div id="add-result" style="margin-top: 10px; display: none;"></div>
        </div>
    </div>

    <!-- Console Modal -->
    <div class="modal" id="console-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Console</div>
                <button class="modal-close" id="console-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="console-controls">
                    <button id="refresh-console-btn"><i class="fas fa-sync-alt"></i> Refresh Logs</button>
                    <button id="clear-console-btn"><i class="fas fa-trash"></i> Clear Console</button>
                    <span style="flex-grow: 1"></span>
                    <label>
                        <input type="checkbox" id="auto-scroll-checkbox" checked>
                        Auto-scroll to bottom
                    </label>
                </div>
                <div class="console-container" id="console-log">
                    <!-- Console logs will be added here dynamically -->
                </div>
                <form id="console-form" class="console-input">
                    <input type="text" id="command-input" placeholder="Enter a command...">
                    <button type="submit"><i class="fas fa-terminal"></i> Execute</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Config Modal -->
    <div class="modal" id="config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Bot Configuration ( reboot bot to apply )</div>
                <button class="modal-close" id="config-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <textarea id="config-editor" class="config-editor" spellcheck="false"></textarea>
                <div style="display: flex; justify-content: center;">
                    <button id="save-config-btn"><i class="fas fa-save"></i> Save Configuration</button>
                </div>
                <div id="config-result" style="margin-top: 15px; padding: 10px; display: none; border-radius: 4px; text-align: center;"></div>
            </div>
        </div>
    </div>

    <!-- Bot Profile Modal -->
    <div class="modal" id="bot-profile-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Bot Profile</div>
                <button class="modal-close" id="bot-profile-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="bot-profile-editor">
                    <div class="current-profile">
                        <img id="profile-avatar" src="https://cdn.discordapp.com/embed/avatars/0.png" alt="Bot Avatar" class="profile-avatar">
                        <div class="profile-name" id="profile-name">Loading...</div>
                    </div>
                    
                    <div class="profile-form">
                        <div class="form-section">
                            <label for="bot-name-input">Bot Name</label>
                            <div class="input-with-button">
                                <input type="text" id="bot-name-input" placeholder="Enter new bot name">
                                <button id="update-name-btn"><i class="fas fa-save"></i> Update Name</button>
                            </div>
                        </div>
                        
                        <div class="form-section">
                            <label for="bot-avatar-input">Bot Avatar URL</label>
                            <div class="input-with-button">
                                <input type="text" id="bot-avatar-input" placeholder="Enter avatar URL">
                                <button id="update-avatar-btn"><i class="fas fa-save"></i> Update Avatar</button>
                            </div>
                        </div>
                    </div>
                    <div id="profile-result" style="margin-top: 15px; padding: 10px; display: none; border-radius: 4px; text-align: center;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container">
        <!-- Toast messages will be added here dynamically -->
    </div>

    <!-- Added YouTube-style time tooltip -->
    <div class="time-tooltip" id="time-tooltip">0:00</div>

    <script>
    let statusInterval;
    let progressInterval;
    let currentStatus = {};
    let currentGuildId = null;
    let servers = [];
    
    // Initialize the app
    window.onload = function() {
        // Initialize modals
        document.getElementById('console-btn').addEventListener('click', () => toggleModal('console-modal', true));
        document.getElementById('console-modal-close').addEventListener('click', () => toggleModal('console-modal', false));
        
        document.getElementById('config-btn').addEventListener('click', () => {
            toggleModal('config-modal', true);
            loadConfig();
        });
        document.getElementById('config-modal-close').addEventListener('click', () => toggleModal('config-modal', false));
        
        // Initialize bot profile modal
        document.getElementById('bot-profile-btn').addEventListener('click', () => {
            toggleModal('bot-profile-modal', true);
            loadBotProfile();
        });
        document.getElementById('bot-profile-modal-close').addEventListener('click', () => toggleModal('bot-profile-modal', false));
        
        // Bot profile form handlers
        document.getElementById('update-name-btn').addEventListener('click', updateBotName);
        document.getElementById('update-avatar-btn').addEventListener('click', updateBotAvatar);
        
        // Initialize reboot button
        document.getElementById('reboot-btn').addEventListener('click', rebootBot);
        
        // Initialize player controls
        document.getElementById('play-button').addEventListener('click', playTrack);
        document.getElementById('pause-button').addEventListener('click', pauseTrack);
        document.getElementById('skip-button').addEventListener('click', skipTrack);
        document.getElementById('stop-button').addEventListener('click', stopTrack);
        
        // Initialize progress bar click
        setupProgressBarInteraction();
        
        // Initialize server dropdown
        const serverDropdownBtn = document.getElementById('server-dropdown-btn');
        const serverDropdownContent = document.getElementById('server-dropdown-content');
        
        serverDropdownBtn.addEventListener('click', () => {
            serverDropdownContent.classList.toggle('show');
        });
        
        // Close dropdown when clicking outside
        window.addEventListener('click', (e) => {
            if (!e.target.matches('.server-select-btn') && !e.target.closest('.server-select-btn')) {
                serverDropdownContent.classList.remove('show');
            }
        });
        
        // Console controls
        document.getElementById('console-form').addEventListener('submit', executeCommand);
        document.getElementById('refresh-console-btn').addEventListener('click', loadConsoleLogs);
        document.getElementById('clear-console-btn').addEventListener('click', () => {
            const consoleLog = document.getElementById('console-log');
            consoleLog.innerHTML = '<div style="color: #B9BBBE;">Console cleared (only in view, logs still exist on server)</div>';
        });
        
        // Config controls
        document.getElementById('save-config-btn').addEventListener('click', saveConfig);
        
        // Load servers and initialize app
        loadServers().then(() => {
            getSelectedGuild().then(guildId => {
                if (guildId) {
                    currentGuildId = guildId;
                    updateServerDisplay();
                }
                
                fetchStatus();
                fetchQueue();
                fetchBotInfo();
                statusInterval = setInterval(fetchStatus, 5000);
                setInterval(fetchQueue, 10000);
                setInterval(fetchBotInfo, 30000);
            });
        });
        
        // Setup add track form
        document.getElementById('add-url-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const url = document.getElementById('url-input').value.trim();
            
            if (!url) {
                showToast('Please enter a URL', false);
                return;
            }
            
            try {
                const response = await fetch('/api/queue/add?url=' + encodeURIComponent(url), {
                    method: 'POST'
                });
                
                const data = await response.json();
                showToast(data.message, data.success);
                
                if (data.success) {
                    document.getElementById('url-input').value = '';
                    fetchQueue();
                    fetchStatus();
                }
            } catch (error) {
                console.error('Error adding track:', error);
                showToast('Error adding track: ' + error.message, false);
            }
        });
    };
    
    // Toggle modal visibility
    function toggleModal(modalId, show) {
        const modal = document.getElementById(modalId);
        if (show) {
            modal.classList.add('show');
            if (modalId === 'console-modal') {
                loadConsoleLogs();
            }
        } else {
            modal.classList.remove('show');
        }
    }
    
    // Load available servers
    async function loadServers() {
        try {
            console.log('Loading servers...');
            const response = await fetch('/api/guilds');
            servers = await response.json();
            console.log('Servers loaded:', servers.length);
            
            const serverDropdownContent = document.getElementById('server-dropdown-content');
            serverDropdownContent.innerHTML = '';
            
            if (servers.length === 0) {
                serverDropdownContent.innerHTML = '<div class="server-item">No servers available</div>';
                return;
            }
            
            servers.forEach(guild => {
                const item = document.createElement('div');
                item.className = 'server-item';
                item.setAttribute('data-id', guild.id);
                
                // Create icon element (using default if none provided)
                const iconUrl = guild.iconUrl || 'https://cdn.discordapp.com/embed/avatars/0.png';
                
                item.innerHTML = `
                    <img class="server-icon" src="${iconUrl}" alt="${guild.name}">
                    <span class="server-name">${guild.name}</span>
                `;
                
                item.addEventListener('click', () => {
                    changeServer(guild.id);
                    document.getElementById('server-dropdown-content').classList.remove('show');
                });
                
                serverDropdownContent.appendChild(item);
            });
        } catch (error) {
            console.error('Error loading servers:', error);
            showToast('Error loading servers', false);
            document.getElementById('server-dropdown-content').innerHTML = '<div class="server-item">Error loading servers</div>';
        }
    }
    
    // Get currently selected guild
    async function getSelectedGuild() {
        try {
            const response = await fetch('/api/guild/selected');
            const data = await response.json();
            return data.guildId;
        } catch (error) {
            console.error('Error getting selected guild:', error);
            return null;
        }
    }
    
    // Update server display
    function updateServerDisplay() {
        if (!currentGuildId || servers.length === 0) return;
        
        const selectedServer = servers.find(server => server.id === currentGuildId);
        if (!selectedServer) return;
        
        document.getElementById('selected-server-name').textContent = selectedServer.name;
        
        // Update icon if available
        const iconElement = document.getElementById('selected-server-icon');
        if (selectedServer.iconUrl) {
            iconElement.src = selectedServer.iconUrl;
        } else {
            iconElement.src = 'https://cdn.discordapp.com/embed/avatars/0.png';
        }
    }
    
    // Change server
    async function changeServer(guildId) {
        if (!guildId) return;
        
        try {
            const response = await fetch(`/api/guild/select/${guildId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                currentGuildId = guildId;
                updateServerDisplay();
                fetchStatus();
                fetchQueue();
                
                showToast('Server changed successfully', true);
            } else {
                showToast(data.message || 'Failed to change server', false);
            }
        } catch (error) {
            console.error('Error changing server:', error);
            showToast('Error changing server', false);
        }
    }
    
    // Format time in MM:SS
    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Update the progress bar
    function updateProgress() {
        if (!currentStatus.playing || currentStatus.paused) return;
        
        const position = currentStatus.currentTrackPosition + 100; // Increment by 100ms
        const duration = currentStatus.currentTrackDuration;
        
        if (position <= duration) {
            currentStatus.currentTrackPosition = position;
            const percentage = (position / duration) * 100;
            document.getElementById('progress-bar').style.width = `${percentage}%`;
            document.getElementById('current-time').textContent = formatTime(position);
        }
    }
    
    // Seek to a position in the track
    function seekTrack(e) {
        if (!currentStatus.playing || !currentStatus.currentTrackDuration) return;
        
        const progressContainer = document.getElementById('progress-container');
        const rect = progressContainer.getBoundingClientRect();
        const clickPosition = (e.clientX - rect.left) / rect.width;
        const seekPosition = Math.floor(clickPosition * currentStatus.currentTrackDuration);
        
        // Update UI instantly for better user experience
        const progressBar = document.getElementById('progress-bar');
        progressBar.style.width = `${clickPosition * 100}%`;
        document.getElementById('current-time').textContent = formatTime(seekPosition);
        
        // Update the current status immediately for a more responsive feel
        currentStatus.currentTrackPosition = seekPosition;
        
        // Animation effect for click feedback
        const progressHandle = document.getElementById('progress-handle');
        progressHandle.style.opacity = '1';
        progressHandle.style.transform = 'translate(-50%, -50%) scale(1.2)';
        progressHandle.style.backgroundColor = '#ffffff';
        
        setTimeout(() => {
            progressHandle.style.transform = 'translate(-50%, -50%)';
        }, 200);
        
        // Send seek request to API
        fetch('/api/seek?position=' + seekPosition, { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Only fetch status after a small delay to avoid 
                    // the progress bar jumping back and forth
                    setTimeout(() => {
                        fetchStatus();
                    }, 300);
                } else {
                    // Revert UI changes if seek failed
                    showToast('Failed to seek: ' + (data.message || 'Unknown error'), false);
                    progressBar.style.width = `${(currentStatus.currentTrackPosition / currentStatus.currentTrackDuration) * 100}%`;
                    document.getElementById('current-time').textContent = formatTime(currentStatus.currentTrackPosition);
                }
            })
            .catch(error => {
                console.error('Error seeking:', error);
                showToast('Error seeking to position', false);
                // Revert UI changes
                progressBar.style.width = `${(currentStatus.currentTrackPosition / currentStatus.currentTrackDuration) * 100}%`;
                document.getElementById('current-time').textContent = formatTime(currentStatus.currentTrackPosition);
            });
    }
    
    // Add progress bar interactivity
    function setupProgressBarInteraction() {
        const progressContainer = document.getElementById('progress-container');
        const progressHandle = document.getElementById('progress-handle');
        const progressPreview = document.getElementById('progress-preview');
        const timeTooltip = document.getElementById('time-tooltip');
        
        // Initialize preview with default values when page loads
        if (currentStatus && currentStatus.currentTrackDuration) {
            progressPreview.textContent = `0:00 / ${formatTime(currentStatus.currentTrackDuration)}`;
        } else {
            progressPreview.textContent = '0:00 / 0:00';
        }
        
        // Function to update mouse tooltip
        function updateTooltip(e) {
            if (!currentStatus.currentTrackDuration) return;
            
            // Calculate position and time
            const rect = progressContainer.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            const previewPosition = Math.floor(position * currentStatus.currentTrackDuration);
            
            // Calculate the exact horizontal position (align with progress handle)
            const handleLeft = rect.left + (position * rect.width);
            
            // Update tooltip content
            timeTooltip.textContent = formatTime(previewPosition);
            
            // Show the tooltip
            timeTooltip.style.display = 'block';
            
            // Position tooltip precisely above the handle
            timeTooltip.style.left = `${handleLeft}px`;
            timeTooltip.style.top = `${rect.top - 10}px`;
        }
        
        progressContainer.addEventListener('mousemove', (e) => {
            if (!currentStatus.currentTrackDuration) return;
            
            const rect = progressContainer.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            const previewPosition = Math.floor(position * currentStatus.currentTrackDuration);
            
            // Update handle position
            progressHandle.style.left = `${position * 100}%`;
            
            // Update preview position and text
            progressPreview.style.left = `${position * 100}%`;
            progressPreview.textContent = `${formatTime(previewPosition)} / ${formatTime(currentStatus.currentTrackDuration)}`;
            progressPreview.style.opacity = '1';
            
            // Update the tooltip
            updateTooltip(e);
        });
        
        progressContainer.addEventListener('mouseleave', () => {
            // Hide handle and preview when mouse leaves
            progressHandle.style.opacity = '0';
            progressPreview.style.opacity = '0';
            timeTooltip.style.display = 'none';
        });
        
        progressContainer.addEventListener('mouseenter', (e) => {
            // Show handle and preview when mouse enters
            progressHandle.style.opacity = '1';
            progressPreview.style.opacity = '1';
            updateTooltip(e);
        });
        
        progressContainer.addEventListener('click', (e) => {
            seekTrack(e);
            timeTooltip.style.display = 'none';
        });
        
        // Hide the tooltip when clicking anywhere else
        document.addEventListener('click', () => {
            timeTooltip.style.display = 'none';
        });
    }
    
    // Fetch current status from the API
    async function fetchStatus() {
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            currentStatus = data;
            
            document.getElementById('track-title').textContent = data.currentTrackTitle || 'No track playing';
            document.getElementById('track-author').textContent = data.currentTrackAuthor || '';
            document.getElementById('queue-info').textContent = `Queue: ${data.queueSize} track${data.queueSize !== 1 ? 's' : ''}`;
            
            // Update metadata with more specific info we added to the API
            if (data.source) {
                document.getElementById('track-source-text').textContent = `Source: ${data.source}`;
            } else {
                document.getElementById('track-source-text').textContent = 'Source: Unknown';
            }
            
            // Update requester from API data
            if (data.requester) {
                document.getElementById('track-requester').textContent = `Requested by: ${data.requester}`;
            } else {
                document.getElementById('track-requester').textContent = 'Requested by: Unknown';
            }
            
            // Update volume from API data
            document.getElementById('track-volume').textContent = `Volume: ${data.volume || 100}%`;
            
            // Update album art container class based on source type
            const albumArt = document.querySelector('.album-art');
            albumArt.className = 'album-art'; // Reset classes
            
            if (data.sourceType) {
                albumArt.classList.add(`${data.sourceType.toLowerCase()}-thumbnail`);
            }
            
            // Update thumbnail based on data from API
            if (data.currentTrackThumbnail) {
                document.getElementById('track-thumbnail').src = data.currentTrackThumbnail;
            } else {
                // Set a default thumbnail based on source type
                const defaultThumbnails = {
                    'YouTube': 'https://www.gstatic.com/youtube/img/branding/youtubelogo/svg/youtubelogo.svg',
                    'SoundCloud': 'https://developers.soundcloud.com/assets/logo_big_white-65c2b096da68dd533db18b5a2bcfbcce.png',
                    'Spotify': 'https://www.freepnglogos.com/uploads/spotify-logo-png/file-spotify-logo-png-4.png',
                    'Local': 'https://cdn-icons-png.flaticon.com/512/4725/4725478.png',
                    'Radio': 'https://static.semrush.com/power-pages/media/favicons/onlineradiobox-com-favicon-7dd1a612.png',
                    'Stream': 'https://cdn-icons-png.flaticon.com/128/11796/11796884.png',
                    'Gensokyo Radio': 'https://stream.gensokyoradio.net/images/logo.png'
                };
                
                const defaultImage = defaultThumbnails[data.sourceType] || 'https://cdn.discordapp.com/embed/avatars/0.png';
                document.getElementById('track-thumbnail').src = defaultImage;
            }
            
            const currentTime = document.getElementById('current-time');
            const totalTime = document.getElementById('total-time');
            
            currentTime.textContent = formatTime(data.currentTrackPosition);
            totalTime.textContent = formatTime(data.currentTrackDuration);
            
            const progressPercentage = (data.currentTrackPosition / data.currentTrackDuration) * 100 || 0;
            document.getElementById('progress-bar').style.width = `${progressPercentage}%`;
            
            // Enable/disable buttons based on playback state
            document.getElementById('play-button').disabled = !data.paused || !data.playing;
            document.getElementById('pause-button').disabled = data.paused || !data.playing;
            document.getElementById('skip-button').disabled = !data.hasNext && !data.playing;
            document.getElementById('stop-button').disabled = !data.playing;
            
            document.getElementById('status-message').textContent = data.playing ? 
                (data.paused ? 'Paused' : 'Playing') : 'Idle';
            
            clearInterval(progressInterval);
            if (data.playing && !data.paused) {
                progressInterval = setInterval(updateProgress, 100);
            }
            
            // Update bot status indicator based on playing status
            updateBotStatusIndicator(data.playing);
        } catch (error) {
            console.error('Error fetching status:', error);
            document.getElementById('status-message').textContent = 'Error connecting to server';
        }
    }
    
    // Fetch queue from the API
    async function fetchQueue() {
        try {
            const response = await fetch('/api/queue');
            const data = await response.json();
            
            const queueList = document.getElementById('queue-list');
            queueList.innerHTML = '';
            
            if (data.length === 0) {
                queueList.innerHTML = '<div style="text-align: center; padding: 20px;">Queue is empty</div>';
                return;
            }
            
            data.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = 'queue-item';
                item.setAttribute('data-index', index);
                item.setAttribute('draggable', 'true');
                
                // For thumbnails in queue, use the right approach based on source type
                let thumbnailUrl = track.thumbnailUrl;
                
                // If no thumbnail provided, or for specific source types, override with defaults
                if (!thumbnailUrl || thumbnailUrl === '') {
                    const defaultThumbnails = {
                        'YouTube': 'https://www.gstatic.com/youtube/img/branding/youtubelogo/svg/youtubelogo.svg',
                        'SoundCloud': 'https://developers.soundcloud.com/assets/logo_big_white-65c2b096da68dd533db18b5a2bcfbcce.png',
                        'Spotify': 'https://www.freepnglogos.com/uploads/spotify-logo-png/file-spotify-logo-png-4.png',
                        'Local': 'https://cdn-icons-png.flaticon.com/512/4725/4725478.png',
                        'Radio': 'https://static.semrush.com/power-pages/media/favicons/onlineradiobox-com-favicon-7dd1a612.png',
                        'Stream': 'https://cdn-icons-png.flaticon.com/128/11796/11796884.png',
                        'Gensokyo Radio': 'https://stream.gensokyoradio.net/images/logo.png'
                    };
                    thumbnailUrl = defaultThumbnails[track.sourceType] || 'https://cdn.discordapp.com/embed/avatars/0.png';
                }
                
                // Add source-specific class for thumbnail styling
                const thumbnailClass = track.sourceType ? 
                    `queue-item-thumbnail ${track.sourceType.toLowerCase()}-thumbnail` : 
                    'queue-item-thumbnail';
                
                // Include source icon and requester info
                const sourceIcon = getSourceIcon(track.sourceType);
                const requesterInfo = track.requester ? ` • Requested by: ${track.requester}` : '';
                
                item.innerHTML = `
                    <div class="drag-handle" title="Drag to reorder">
                        <i class="fas fa-grip-lines"></i>
                    </div>
                    <div class="${thumbnailClass}">
                        <img src="${thumbnailUrl}" alt="${track.title}">
                    </div>
                    <div class="queue-item-info">
                        <div class="queue-item-title">${index + 1}. ${track.title}</div>
                        <div class="queue-item-meta">
                            <span class="queue-item-author">${track.author}</span>
                            <span class="queue-item-source"><i class="${sourceIcon}"></i> ${track.source}</span>
                            <span class="queue-item-requester">${requesterInfo}</span>
                        </div>
                    </div>
                    <div class="queue-item-duration">${formatTime(track.duration)}</div>
                    <div class="queue-item-actions">
                        <button class="move-top-btn" data-index="${index}" title="Move to top">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="move-bottom-btn" data-index="${index}" title="Move to bottom">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="remove-btn" data-index="${index}" title="Remove from queue">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                queueList.appendChild(item);
            });
            
            // Add event listeners to remove buttons
            document.querySelectorAll('.remove-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const index = e.target.closest('.remove-btn').getAttribute('data-index');
                    await removeFromQueue(index);
                });
            });
            
            // Add event listeners to move-top buttons
            document.querySelectorAll('.move-top-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.closest('.move-top-btn').getAttribute('data-index'));
                    if (index > 0) {
                        await moveTrack(index, 0);
                    }
                });
            });
            
            // Add event listeners to move-bottom buttons
            document.querySelectorAll('.move-bottom-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.closest('.move-bottom-btn').getAttribute('data-index'));
                    const queueSize = data.length;
                    if (index < queueSize - 1) {
                        await moveTrack(index, queueSize - 1);
                    }
                });
            });
            
            // Set up drag and drop functionality
            setupDragAndDrop();
            
        } catch (error) {
            console.error('Error fetching queue:', error);
        }
    }
    
    // Set up drag and drop for queue items
    function setupDragAndDrop() {
        const queueItems = document.querySelectorAll('.queue-item');
        let draggedItem = null;
        
        queueItems.forEach(item => {
            // Drag start event
            item.addEventListener('dragstart', function(e) {
                draggedItem = this;
                setTimeout(() => {
                    this.classList.add('dragging');
                }, 0);
            });
            
            // Drag end event
            item.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                draggedItem = null;
                document.querySelectorAll('.drag-over').forEach(item => {
                    item.classList.remove('drag-over');
                });
            });
            
            // Drag over event
            item.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (this !== draggedItem) {
                    this.classList.add('drag-over');
                }
            });
            
            // Drag leave event
            item.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });
            
            // Drop event
            item.addEventListener('drop', async function(e) {
                e.preventDefault();
                if (draggedItem && this !== draggedItem) {
                    const fromIndex = parseInt(draggedItem.getAttribute('data-index'));
                    const toIndex = parseInt(this.getAttribute('data-index'));
                    
                    this.classList.remove('drag-over');
                    await moveTrack(fromIndex, toIndex);
                }
            });
        });
    }
    
    // Move track in queue
    async function moveTrack(fromIndex, toIndex) {
        try {
            // Add 1 to indexes because API uses 1-based indexing (while JavaScript uses 0-based)
            const response = await fetch(`/api/queue/move?from=${fromIndex + 1}&to=${toIndex + 1}`, {
                method: 'POST'
            });
            
            const data = await response.json();
            if (data.success) {
                fetchQueue();
                showToast(`Track moved from position ${fromIndex + 1} to ${toIndex + 1}`, true);
            } else {
                showToast(data.message || 'Failed to move track', false);
            }
        } catch (error) {
            console.error('Error moving track:', error);
            showToast('Error moving track', false);
        }
    }
    
    // Get appropriate icon based on source type
    function getSourceIcon(sourceType) {
        const icons = {
            'YouTube': 'fab fa-youtube',
            'SoundCloud': 'fab fa-soundcloud',
            'Spotify': 'fab fa-spotify',
            'Local': 'fas fa-file-audio',
            'Radio': 'fas fa-broadcast-tower',
            'Stream': 'fas fa-signal'
        };
        
        return icons[sourceType] || 'fas fa-music';
    }
    
    // Control functions
    async function playTrack() {
        try {
            const response = await fetch('/api/play', { method: 'POST' });
            const data = await response.json();
            if (data.success) {
                fetchStatus();
            }
        } catch (error) {
            console.error('Error playing track:', error);
            showToast('Error playing track', false);
        }
    }
    
    async function pauseTrack() {
        try {
            const response = await fetch('/api/pause', { method: 'POST' });
            const data = await response.json();
            if (data.success) {
                fetchStatus();
            }
        } catch (error) {
            console.error('Error pausing track:', error);
            showToast('Error pausing track', false);
        }
    }
    
    async function skipTrack() {
        try {
            const response = await fetch('/api/skip', { method: 'POST' });
            const data = await response.json();
            if (data.success) {
                fetchStatus();
                fetchQueue();
            }
        } catch (error) {
            console.error('Error skipping track:', error);
            showToast('Error skipping track', false);
        }
    }
    
    async function stopTrack() {
        try {
            const response = await fetch('/api/stop', { method: 'POST' });
            const data = await response.json();
            if (data.success) {
                fetchStatus();
                fetchQueue();
            }
        } catch (error) {
            console.error('Error stopping playback:', error);
            showToast('Error stopping playback', false);
        }
    }
    
    async function removeFromQueue(index) {
        try {
            const response = await fetch(`/api/queue/${index}`, { method: 'DELETE' });
            const data = await response.json();
            if (data.success) {
                fetchQueue();
                fetchStatus();
                showToast('Track removed from queue', true);
            }
        } catch (error) {
            console.error('Error removing track from queue:', error);
            showToast('Error removing track from queue', false);
        }
    }

    // Show toast notification
    function showToast(message, success) {
        const toastContainer = document.getElementById('toast-container');
        
        const toast = document.createElement('div');
        toast.className = `toast ${success ? 'success' : 'error'}`;
        toast.textContent = message;
        
        toastContainer.appendChild(toast);
        
        // Remove toast after animation completes
        setTimeout(() => {
            toast.remove();
        }, 5000);
    }
    
    // Console functions
    async function loadConsoleLogs() {
        try {
            const response = await fetch('/api/console/logs');
            const logs = await response.json();
            
            const consoleLog = document.getElementById('console-log');
            consoleLog.innerHTML = '';
            
            if (logs.length === 0) {
                consoleLog.innerHTML = '<div style="color: #B9BBBE;">No logs available</div>';
                return;
            }
            
            logs.forEach(log => {
                const logLine = document.createElement('div');
                logLine.className = 'console-log-entry';
                
                // Add specific styling based on log content
                if (log.startsWith('>')) {
                    logLine.className += ' command';
                } else if (log.toLowerCase().includes('error') || log.toLowerCase().includes('exception')) {
                    logLine.className += ' error';
                } else if (log.toLowerCase().includes('info') || log.toLowerCase().includes('loaded') || log.toLowerCase().includes('started')) {
                    logLine.className += ' info';
                }
                
                logLine.textContent = log;
                consoleLog.appendChild(logLine);
            });
            
            // Auto-scroll to bottom if enabled
            if (document.getElementById('auto-scroll-checkbox').checked) {
                consoleLog.scrollTop = consoleLog.scrollHeight;
            }
            
        } catch (error) {
            console.error('Error loading console logs:', error);
            const consoleLog = document.getElementById('console-log');
            consoleLog.innerHTML = '<div class="console-log-entry error">Error loading console logs: ' + error.message + '</div>';
        }
    }
    
    async function executeCommand(e) {
        e.preventDefault();
        const commandInput = document.getElementById('command-input');
        const command = commandInput.value.trim();
        
        if (!command) return;
        
        try {
            const response = await fetch('/api/console/command?command=' + encodeURIComponent(command), {
                method: 'POST'
            });
            
            const data = await response.json();
            
            // Clear the input
            commandInput.value = '';
            
            // Refresh logs
            loadConsoleLogs();
            
        } catch (error) {
            console.error('Error executing command:', error);
            const consoleLog = document.getElementById('console-log');
            const errorLine = document.createElement('div');
            errorLine.className = 'console-log-entry error';
            errorLine.textContent = 'Error executing command: ' + error.message;
            consoleLog.appendChild(errorLine);
            
            if (document.getElementById('auto-scroll-checkbox').checked) {
                consoleLog.scrollTop = consoleLog.scrollHeight;
            }
        }
    }
    
    // Config functions
    async function loadConfig() {
        try {
            const response = await fetch('/api/console/config');
            const data = await response.json();
            
            const configEditor = document.getElementById('config-editor');
            
            if (data.success) {
                configEditor.value = data.content;
            } else {
                configEditor.value = data.message || 'Error loading configuration';
            }
            
        } catch (error) {
            console.error('Error loading config:', error);
            document.getElementById('config-editor').value = 'Error loading configuration: ' + error.message;
        }
    }
    
    async function saveConfig() {
        const configContent = document.getElementById('config-editor').value;
        const configResult = document.getElementById('config-result');
        
        try {
            const response = await fetch('/api/console/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content: configContent })
            });
            
            const data = await response.json();
            
            showToast(data.success ? 'Configuration saved successfully' : (data.message || 'Failed to save configuration'), data.success);
            
        } catch (error) {
            console.error('Error saving config:', error);
            showToast('Error saving configuration: ' + error.message, false);
        }
    }
    
    // Reboot the bot
    async function rebootBot() {
        if (!confirm('Are you sure you want to reboot the bot? This will interrupt any current playback.')) {
            return;
        }
        
        try {
            showToast('Attempting to reboot the bot...', true);
            
            const response = await fetch('/api/reboot', {
                method: 'POST'
            });
            
            const data = await response.json();
            
            if (data.success) {
                showToast('Bot is rebooting. It should be back online shortly.', true);
                
                // Disable all controls during reboot
                document.getElementById('play-button').disabled = true;
                document.getElementById('pause-button').disabled = true;
                document.getElementById('skip-button').disabled = true;
                document.getElementById('stop-button').disabled = true;
                document.getElementById('reboot-btn').disabled = true;
                
                // Status update
                document.getElementById('status-message').textContent = 'Rebooting...';
                
                // Check if bot is back online after a delay
                setTimeout(checkBotStatus, 5000);
            } else {
                showToast(data.message || 'Failed to reboot the bot', false);
            }
        } catch (error) {
            console.error('Error rebooting the bot:', error);
            showToast('Error rebooting the bot: ' + error.message, false);
        }
    }
    
    // Check if bot is back online
    async function checkBotStatus() {
        try {
            const response = await fetch('/api/status');
            
            if (response.ok) {
                showToast('Bot is back online!', true);
                document.getElementById('reboot-btn').disabled = false;
                
                // Refresh everything
                fetchStatus();
                fetchQueue();
                loadServers();
            } else {
                // Try again in a few seconds
                setTimeout(checkBotStatus, 5000);
            }
        } catch (error) {
            // Bot is still restarting, try again
            setTimeout(checkBotStatus, 5000);
        }
    }

    // Fetch bot information
    async function fetchBotInfo() {
        try {
            const response = await fetch('/api/bot/info');
            const data = await response.json();
            
            if (data.success) {
                // Update bot name and avatar in the header
                document.getElementById('bot-name').textContent = data.name || 'JMusicBot';
                
                if (data.avatarUrl) {
                    document.getElementById('bot-avatar').src = data.avatarUrl;
                } else {
                    document.getElementById('bot-avatar').src = 'https://cdn.discordapp.com/embed/avatars/0.png';
                }
                
                // Make the bot profile button display a tooltip on hover
                document.getElementById('bot-profile-btn').title = `${data.name} - Bot ID: ${data.id}`;
            }
        } catch (error) {
            console.error('Error fetching bot info:', error);
            // Set fallback values
            document.getElementById('bot-name').textContent = 'JMusicBot';
            document.getElementById('bot-avatar').src = 'https://cdn.discordapp.com/embed/avatars/0.png';
        }
    }
    
    // Update bot status indicator based on playing status
    function updateBotStatusIndicator(isPlaying) {
        const statusIndicator = document.getElementById('bot-status-indicator');
        
        if (isPlaying) {
            statusIndicator.classList.add('active');
        } else {
            statusIndicator.classList.remove('active');
        }
    }

    // Bot profile functions
    async function loadBotProfile() {
        try {
            const response = await fetch('/api/bot/info');
            const data = await response.json();
            
            if (data.success) {
                document.getElementById('profile-avatar').src = data.avatarUrl || 'https://cdn.discordapp.com/embed/avatars/0.png';
                document.getElementById('profile-name').textContent = data.name || 'JMusicBot';
                
                // Pre-fill the input fields with current values for better UX
                document.getElementById('bot-name-input').value = data.name || '';
                document.getElementById('bot-avatar-input').value = data.avatarUrl || '';
            }
            
            // Reset and hide the result message
            const profileResult = document.getElementById('profile-result');
            profileResult.textContent = '';
            profileResult.style.display = 'none';
            
        } catch (error) {
            console.error('Error loading bot profile:', error);
            document.getElementById('profile-avatar').src = 'https://cdn.discordapp.com/embed/avatars/0.png';
            document.getElementById('profile-name').textContent = 'JMusicBot';
        }
    }

    async function updateBotName() {
        const newName = document.getElementById('bot-name-input').value.trim();
        const profileResult = document.getElementById('profile-result');
        profileResult.style.display = 'block';
        
        if (!newName) {
            profileResult.textContent = 'Please enter a name';
            profileResult.style.backgroundColor = 'var(--error-color)';
            profileResult.style.color = 'white';
            return;
        }
        
        try {
            const formData = new FormData();
            formData.append('name', newName);
            
            const response = await fetch('/api/bot/setname', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            
            if (data.success) {
                document.getElementById('profile-name').textContent = newName;
                document.getElementById('bot-name').textContent = newName; // Update in header too
                profileResult.textContent = 'Bot name updated successfully';
                profileResult.style.backgroundColor = 'var(--success-color)';
                profileResult.style.color = 'white';
                
                // Refresh bot info in case any other info changed
                fetchBotInfo();
            } else {
                profileResult.textContent = data.message || 'Failed to update bot name';
                profileResult.style.backgroundColor = 'var(--error-color)';
                profileResult.style.color = 'white';
            }
        } catch (error) {
            console.error('Error updating bot name:', error);
            profileResult.textContent = 'Error updating bot name: ' + error.message;
            profileResult.style.backgroundColor = 'var(--error-color)';
            profileResult.style.color = 'white';
        }
    }

    async function updateBotAvatar() {
        const newAvatarUrl = document.getElementById('bot-avatar-input').value.trim();
        const profileResult = document.getElementById('profile-result');
        profileResult.style.display = 'block';
        
        if (!newAvatarUrl) {
            profileResult.textContent = 'Please enter an avatar URL';
            profileResult.style.backgroundColor = 'var(--error-color)';
            profileResult.style.color = 'white';
            return;
        }
        
        try {
            const formData = new FormData();
            formData.append('url', newAvatarUrl);
            
            const response = await fetch('/api/bot/setavatar', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            
            if (data.success) {
                document.getElementById('profile-avatar').src = newAvatarUrl;
                document.getElementById('bot-avatar').src = newAvatarUrl; // Update in header too
                profileResult.textContent = 'Bot avatar updated successfully';
                profileResult.style.backgroundColor = 'var(--success-color)';
                profileResult.style.color = 'white';
                
                // Refresh bot info in case any other info changed
                fetchBotInfo();
            } else {
                profileResult.textContent = data.message || 'Failed to update bot avatar';
                profileResult.style.backgroundColor = 'var(--error-color)';
                profileResult.style.color = 'white';
            }
        } catch (error) {
            console.error('Error updating bot avatar:', error);
            profileResult.textContent = 'Error updating bot avatar: ' + error.message;
            profileResult.style.backgroundColor = 'var(--error-color)';
            profileResult.style.color = 'white';
        }
    }
    </script>
</body>
</html> 